<script lang="ts" generics="Item extends { id: any }">
	import type { Snippet } from 'svelte';
	import adminApiClient from '$lib/util/adminApiClient';
	import { getNotificationContext } from '$components/NotificationProvider.svelte';
	import type { WithoutID } from '$lib/types/crud/globalCrud';

	type ItemWithoutID = WithoutID<Item>;

	interface ItemListDisplayProps {
		items: ItemDisplayProps[];
		create: () => void;
		reorder: (order: number[]) => void;
		updateAll: (items: ItemWithoutID[]) => void;
	}

	interface ItemDisplayProps {
		id: Item['id']; // Unique identifier, copied from the item's id
		item: Item;
		index: number;
		duplicate: () => void;
		update: (item: ItemWithoutID) => void;
		remove: () => void;
	}

	interface Props {
		/**
		 * The service ID to use for the api calls. Required.
		 */
		serviceId: string;
		/**
		 * The items to display in the list. Bindable.
		 */
		items: Item[];
		/**
		 * Function to generate a new item. Required if `canCreate` is true (which it defaults to).
		 */
		generateNewItem?: () => ItemWithoutID;
		renderItems?: Snippet<[ItemListDisplayProps]>;
		canCreate?: boolean;
		canDuplicate?: boolean;
		canUpdate?: boolean;
		canRemove?: boolean;

		canReorder?: boolean;
		sortFn?: (a: Item, b: Item) => number;
		/**
		 * The initial order of the items. This is required if `canReorder` is true.
		 */
		initialOrder?: Item['id'][];
	}

	let {
		serviceId,
		items: initialItems = $bindable([]),
		generateNewItem,
		renderItems,
		canCreate = true,
		canDuplicate = true,
		canUpdate = true,
		canRemove = true,

		canReorder = false,
		initialOrder,
		sortFn
	}: Props = $props();

	const notificationContext = getNotificationContext();

	let items: Item[] = $state(initialItems);
	$effect(() => {
		initialItems = sort(items); // Sync the prop with the state
	});

	let order: Item['id'][] | undefined = $state(
		canReorder && initialOrder ? sanitizeOrder(initialOrder) : undefined
	);

	function onHttpError(err: Error) {
		notificationContext.show(err.message, 'error');
	}

	function refetch() {
		adminApiClient.getAll<Item>(serviceId).then((res) => {
			items = res.results;
			if (canReorder && res.order) order = res.order;
		}).catch(onHttpError);
	}

	function create() {
		if (!canCreate) return;
		if (!generateNewItem) throw new Error('Missing generateNewItem function');

		// I could use the commented code below to generate a new item w/ a temp id, but I prefer to have the id generated by the server
		/*const newTempId = generateRandomId();
		const newItem = generateNewItem();

		items.push({ ...newItem, id: newTempId } as Item);
		items = items; // Force reactivity

		if (canReorder) {
			order!.push(newTempId); // Keep order in sync
			order = order; // Force reactivity
		}*/

		const newItem = generateNewItem();
		adminApiClient.create<Item>(serviceId, newItem).then((res) => {
			items = res.results;
			if (canReorder && res.order) order = res.order;
		}).catch(onHttpError);
	}

	function duplicate(id: Item['id']) {
		if (!canDuplicate) return;

		const item = items.find((item) => item.id === id);
		if (item === undefined) return;
		delete item.id; // Remove the id to create a new item

		// I could use the commented code below to duplicate an item w/ a temp id, but I prefer to have the id generated by the server
		/*const clonedItem = JSON.parse(JSON.stringify(item));
		const newTempId = generateRandomId();
		items.push({ ...clonedItem, id: newTempId });
		items = items; // Force reactivity

		if (canReorder) {
			const index = order!.indexOf(id);
			order!.splice(index + 1, 0, newTempId); // Keep order in sync
			order = order; // Force reactivity
		}*/

		adminApiClient.create<Item>(serviceId, item).then((res) => {
			items = res.results;
			if (canReorder && res.order) order = res.order;
		}).catch(onHttpError);
	}

	function update(id: Item['id'], item: ItemWithoutID) {
		if (!canUpdate) return;

		const index = items.findIndex((i) => i.id === id);
		if (index === -1) return;

		// We can update it immediately, as the server will return the updated item
		items[index] = { ...item, id: id } as Item;

		adminApiClient.update<Item>(serviceId, id, item).then((res) => {
			// Update the item with the result from the server, in case it was modified
			const index = items.findIndex((i) => i.id === id);
			if (index === -1) return;
			items[index] = res.result;
		}).catch((err) => {
			onHttpError(err);
			refetch(); // Re-fetch the items to ensure they are in sync
		});
	}

	function remove(id: Item['id']) {
		if (!canRemove) return;

		const index = items.findIndex((item) => item.id === id);
		if (index === -1) return;

		// We can update it immediately, as the server will return the updated list for sync
		items.splice(index, 1);
		items = items; // Force reactivity

		if (canReorder) {
			order!.splice(order!.indexOf(id), 1); // Keep order in sync
			order = order; // Force reactivity
		}

		adminApiClient.remove<Item>(serviceId, id).then((res) => {
			items = res.results;
			if (canReorder && res.order) order = res.order;
		}).catch((err) => {
			onHttpError(err);
			refetch(); // Re-fetch the items to ensure they are in sync
		});
	}

	function updateAll(newItems: ItemWithoutID[]) {
		// I could use the commented code below to duplicate an item w/ a temp id, but I prefer to have the id generated by the server
		// items = newItems;
		// if (canReorder) {
		// 	if (!newOrder) throw new Error('Missing order when updating all items');
		// 	order = sanitizeOrder(newOrder!); // Ensure the order is still valid
		// }

		adminApiClient.overwriteAll<Item>(serviceId, newItems).then((res) => {
			items = res.results;
			if (canReorder && res.order) order = res.order;
		}).catch((err) => {
			onHttpError(err);
			refetch(); // Re-fetch the items to ensure they are in sync
		});
	}

	function sort(_items: Item[]) {
		if (canReorder) return [..._items].sort((a, b)=>order!.indexOf(a.id) - order!.indexOf(b.id));
		else if (sortFn) return [..._items].sort(sortFn);
		else return _items;
	}

	function reorder(newOrder: Item['id'][]) {
		if (!canReorder) return;

		// Make sure the new order is valid
		newOrder = sanitizeOrder(newOrder);

		order = newOrder;

		adminApiClient.reorder<Item>(serviceId, newOrder).then((res) => {
			order = res.order;
		}).catch(onHttpError);
	}

	function sanitizeOrder(newOrder: Item['id'][]) {
		newOrder = newOrder
			.filter((item, pos, self) => self.indexOf(item) == pos) // Remove duplicates
			.filter((id) => items.findIndex((i) => i.id === id) !== -1); // Ensure all ids in "newOrder" are present in "items"
		if (items.some((i) => newOrder.indexOf(i.id) === -1))
			throw new Error('Invalid CRUD order of items'); // Ensure all items have an id in "newOrder"
		return newOrder;
	}
</script>

{@render renderItems?.({
	items: sort(items).map(
		(_item, index) =>
			({
				id: _item.id,
				item: _item,
				index,
				duplicate: () => duplicate(_item.id),
				update: (item: ItemWithoutID) => update(_item.id, item),
				remove: () => remove(_item.id)
			}) as ItemDisplayProps
	),
	create,
	reorder,
	updateAll
})}
